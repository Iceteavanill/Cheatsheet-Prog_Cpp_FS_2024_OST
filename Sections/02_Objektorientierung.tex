\section{Objektorientierung}

Objektorientierung soll es erleichtern eine Abbildung der Realität zu erstellen. 
Viele Dinge aus der Wirklichkeit können als Modell dargestellt / simplifiziert werden.\\
Diese Modelle können in Software in sogenannte Objekte \say{umgewandelt} werden.

\subsection{Objekte}

Objekte stellen Dinge, Sachverhalte oder Prozesse dar. Sie sind ein rein gedankliches Konzept.\\
Sie kennzeichnen sich durch:

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item eine Identität, welche es erlaubt Objekte voneinander zu unterscheiden
    \item statische Eigenschaften zur Darstellung des Zustandes des Objekts in Form von Attributen
    \item dynamische Eigenschaften zur Darstellung des Verhaltens des Objekts in Form von Methoden
\end{itemize}

\nextcol

\subsection{Klassen \& Instanzen}

Ähnliche Objekte können in \textbf{Klassen} zusammengefasst werden, um Programmieraufwand tiefer zu halten. 
Verwendete Objekte werden als \textbf{Instanz} eingesetzt. Diese Objekte haben dieselben Attribute, allerdings andere Werte.\\
Eine Beispielklasse:\\

\lstinputlisting[language = c++]{code/class_example.cpp}

\subsubsection{Header Datei}

Reihenfolge in der Header Datei

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Dateikommentar mit Lizenzvereinbarung.
    \item \say{Includes} des verwendete System Header
    \item \say{Includes} der Projektbezogenen Header
    \item Konstanten
    \item typdefs und definition von Strukturen
    \item Allenfalls extern-Deklraration von Global Variablen
    \item Funktionsprototypen, ink, Kommentar der Schnittstelle, bzw. Klassendeklarationen
\end{itemize}

Pro header Datei sollte nur eine Klasse deklariert sein.

\subsubsection{Reihenfolger der Implementation}

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Dateikommentar mit Lizenzvereinbarung
    \item \say{includes} der eigenen Header
    \item \say{includes} der Projektbezogenen Header
    \item \say{includes} der verwendeten System Header
    \item allenfalls globale und statischen Variablen
    \item Präprozessor-Direktiven
    \item Funktionsprototypen von lokalen, internen Funktionen (in nameless Namespace)
    \item Definition von Funktionen und Klassen
\end{itemize}

\subsection{UML}

Die \say{Unified Modeling Language} ist eine normierte Sprache um Objekte Grafisch darzustellen. 
Sie geht extrem ins Detail, allerdings 

\subsubsection{UML-Klassendiagramm Notation}

Besteht immer aus 3 Boxen:

\begin{center}
    \begin{tikzpicture} 
        \umlclass{Student}{ 
          + IDNumber : int \\ \#{} name : std::string \\ + bierkonsum : float \\ + investedTimeInET : long int 
          }{ 
          + doStuff(int time = 0) : void 
        } 
    \end{tikzpicture}   
\end{center}

Zu oberst der Name, in der Mitte Attribute(Variablen) und unten Methoden.\\
Die Methoden fangen mit einem Symbol an welches die Sichtbarkeit definiert:
\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item + public (überall sichtbar)
    \item - private (nur in  aktueller klasse sichtbar)
    \item \# protected (in aktueller und Unterklassen sichtbar)
\end{itemize}


\subsubsection{class \& struct}

Eine class und struct können fast identisch verwendet werden. 
Eine class hat standartmässig sichtbarkeit private, struct public(wenn nichts definiert wird).


\subsection{Inkludierte Dokumentation}

Mann im H-File direkt die Dokumentation zu der Schnittstelle schreiben. 
Das ermöglicht das einfachere Verwenden der Schnittstelle.
Dies wird in einem Blockkommentar, nach folgendem Muster realisiert:

\lstinputlisting[language = c++]{code/codedocumentation.cpp}

Es kann immer mehr geschrieben werden, es sollte sich aber auf das nötige beschränkt werden.

\section{Konstruktoren und Destruktoren}

Konstruktoren und Destruktoren sind spezielle Methoden von Klassen. 
Diese haben immer denselben Namen wie die Klasse und auch \textbf{kein} Rückgabetyp(auch nicht void).\\
Aufrufparameter haben folgende Bedeutung:

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item \textbf{\say{Keine}} : Default Konstruktor
    \item \textbf{\say{const-Referenz auf eigene Klasse}} : copy Konstruktor
    \item .....
\end{itemize}

\subsection{Konstruktoren}

Konstruktoren bereiten die Instanz auf ihre Funktion vor. \\

Wichtig ist das ein Konstruktor immer \textbf{alle} Attribute der Klasse initialisiert.
Konstruktoren werden wie folgt aufgerufen:\\

\subsubsection{User-Defined}

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Default $\rightarrow$ ohne Aufrufparameter
    \item Copy $\rightarrow$ mit einer const Referenz auf eine andere Instanz
    \item sonstige $\rightarrow$ werden anhand ihrer Aufrufparameter unterschieden, Sprechweise:\say{überladen}
\end{itemize}

Werden verschiedene Konstruktoren definiert, der Default aber soll erhalten bleiben, muss dieser in der Klassendefinition zuerst stehen.\\


\subsubsection{Implizit}

Falls ein expliziter nicht angegeben wurde, dieser jedoch aus technischen Gründen benötigt wird:

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Default $\rightarrow$ macht nichts, alle Parameter bleibe uninitialisiert
    \item Copy $\rightarrow$ dieser kopiert alle Attribute der anderen Instanz eins-zu-eins(bytewise). Problematisch, wenn die Instanz Pointer auf etwas hat.
    \item ...
\end{itemize}

Wenn ein Objekt ein Pointer auf einen Wert oder allokierten Speicher hat, muss eine spezielle Copy Methode verwendet werden, da der Pointerwert einfach kopiert wird.
Falls dann das erste Objekt den Speicher frei gibt, dann entsteht ein falscher Speicherzugriff.
DH mus dem Objekt ein separater Speicherbereich gegeben werden. 

Konstruktoren werden immer dann gerufen (evtl. auch \textbf{implizit}) wenn ein neues Objekt in den Speicher gelegt wird.\\

\subsection{Destruktor}

Destruktoren entfernen das Objekt aus dem Speicher. 
Hat keine Aufrufparameter und auch kein Rückgabewert.
Wenn der Destruktor fertig ist, sollte kein Speicher mehr vom Objekt belegt sein.\\
Destruktoren sollten immer \textbf{Virtuell definiert werden} und der Funktionsname beginnt mit einer Tilde. 
Der Destruktor wird evtl. auch Implizit aufgerufen z.b., wenn aus einer Funktion wieder herausgesprungen wird. 
\nextcol

\subsection{Beispiel}

\lstinputlisting[language = c++]{code/constructor.cpp}

\section{Initialisierungslisten und direkte Initialisierung}

Die Initialisierung von Datentypen kann auf verschiedene Arten erreicht werden. 
Es wird zwischen Zuweisung und Initialisierung unterschieden.

\subsection{POD's}

\say{plain old datastructure} / built in 

\lstinputlisting[language = c++]{code/pod_init.cpp}

\subsection{Non PODs}

\lstinputlisting[language = c++]{code/non_pod_init.cpp}

\subsection{User defined Ctor}

Um eine Klasse richtig initialisieren zu können muss der Ctor korrekt definiert werden. 
Eine sogenannte Initialisierungsliste:

\lstinputlisting[language = c++]{code/userdefined_ctro.cpp}

\section{Assertions}

Assertions sollten Annahmen über korrekte Wertebelegung darstellen. 
Sie sind kein C spezifisches Konzept und sollten nur zu Testzwecken eingesetzt werden. 
Im Releasebuild sollten sie deaktiviert werden. 
Dafür gibt es spezifische Präprozessorflags.
Der Header assert.h bzw. cassert stellt hierfür ein Präprozessor-Makro \say{assert(Bedingung)} zur Verfügung, um solche Zusicherungen auszudrücken.\\
Beispiel:\\

\lstinputlisting[language = c++]{code/assertions.cpp}

Das obige Beispiel hat eine Assertion. 
Diese würde im Test, falls ein Nullpointer übergeben wird ein Fehler ausgegeben. 

\subsection{This-Pointer}

Mit dem \say{this Pointer} kann ein Pointer des aufrufenden Objekt zurückgegeben werden. Bsp:

\lstinputlisting[language = c++]{code/this_pointer.cpp}

Nacheinander werden diese Funktionen durchlaufen da Funktion(2) vom zurückgegebenen Pointer aus Funktionsaufruf 1 aus gerufen wird.
Die funktion wird \say{Kaskadiert}


\section{Overloading}

Operator Overloading bedeutet das bestehende Operatoren \say{überladen} werden im Sinne neu definiert / drüber laden und erhalten neue bedeutung für eine Klasse. 


\subsubsection{Methodenoverloading}

Methoden dürfen in Cpp gleich heissen, sie müssen aber unterschiedliche Aufrufparameter haben.
\lstinputlisting[language = c++]{code/method_overloading.cpp}


\subsection{Operator overloading}

Es können die inkludierten Operatoren von Cpp überladen werden. 
Erlaubte Operatoren sind:\\
\begin{tabular}{lllllllll}
    +            & -               & *           & ⁄                      & \%                           & $\wedge$                & \&                            & $|$              & $\sim$          \\
    !            & =               & \textless{} & \textgreater{}         & +=                           & -=                      & *=                            & ⁄=               & \%=             \\
    $\wedge$=    & \&=             & $|$=        & \textless{}\textless{} & \textgreater{}\textgreater{} & \textless{}\textless{}= & \textgreater{}\textgreater{}= & ==               & !=              \\
    \textless{}= & \textgreater{}= & \&\&        & $\|$                   & ++                           & $--$                    & ,                             & -\textgreater{}* & -\textgreater{} \\
    ( )          & {[} {]}         & new         & delete                 & new{[}{]}                    & delete{[}{]}            &                               &                  &                
\end{tabular}

Nicht erlaubte Operatoren sind: \say{.} \say{.*} \say{::} und \say{?:}.

Es wird zwischen overloading global und in Methode unterschieden.

\subsubsection{Global}

Globales overloading funktioniert mit einer als \say{friend} deklarierten Funktion. 
Als friend deklarierte Funktionen agieren als globale Funktion und haben vollen zugriff auf alle Parameter einer Klasse. 
Sie sind daher zu vermeiden da sie eher ein Workaround sind und zu Problemen führen können.\\ 

Syntax : \say{return-type} operator\say{typ}(type val1, type val2);\\
BSP:\\

\lstinputlisting[language = c++]{code/operator_overloading_global.cpp}

Die Funktion kann von überall aus dem Programm ausgeführt werden. 
Es sollte nur dann verwendet werden wenn der erste Parameter (links) nicht eine Instanz der Klasse ist da der Erste Aufrufparameter immer die Instanz sein muss.  

\subsubsection{Methoden}

Ein Operator kann auch als Methode einer Klasse definiert werden. 
Sie haben nur noch ein Aufrufparameter.\\
Syntax : \say{return-type} operator\say{typ}(type in);\\
Der 2. Parameter ist das Objekt selbst, welche die Methode aufruft.

\lstinputlisting[language = c++]{code/operator_overloading_method.cpp}

Die obigen Funktionen machen alle dasselbe. 
Sie unterscheiden sich durch die unterschiedlichen Argumente. 
Diese decken verschiedene Eingabetypen ab. 
Es wäre schlechter Stil, die Typkonvertierung dem Compiler implizit zu überlassen! 
Ein Fall, der bei dem das anderstypige Argument zuerst kommt, muss noch per Globalem Overloading gelöst werden, da der Erste Aufrufparameter, beim overloading mit Methoden, immer zuerst kommt. 
 
\subsection{Default Argumente}

Default Argumente werden, als Parameterwert verwendet, wenn keiner mitgegeben wird.
Parameter werden von links nach rechts werten belegt. 
Daher, wenn manche Aufrufparameter keinen Default wert erhalten, müssen diese weiter links, als welche mit Default wert stehen.  

\lstinputlisting[language = c++]{code/default_argumente.cpp}

Default Argumente können überall verwendet werden, bei Aufrufparameter von Operatoroverloading macht es lediglich keinen Sinn.

\subsection{Getter \& Settermethoden}

Getter und Settermethoden werden Typischerweise verwendet um lese und Schreibzugriffe auf eine Klasse zu regeln. 
Attribute sind typischerweise privat. 
Mit einer Get oder Set methode kann dieser kontrollierter angepasst  werden.\\

\lstinputlisting[language = c++]{code/getter_settermethoden.cpp}

\section{Vererbung}

Vererbung erlaubt es Attribute und Methoden von anderen Klassen zu übernehmen. 
Die Oberklasse, Baisklasse oder superklasse \say{vererbt} an eine Unterklasse, derived class oder eine Spezialisierung. 
Bei der Vererbung werden immer \textbf{Alle} Attribute oder Methoden weitergegeben.  


\subsubsection{UML}

In einem UML Diagramm wird vererbung wie folgt dargestellt:\\

\begin{center}
    \begin{tikzpicture} 
        \umlclass{Superklasse}{....}{...}
        \umlclass[x=5]{Unterklasse}{...}{...}
        \umlinherit{Unterklasse}{Superklasse}
    \end{tikzpicture}   
\end{center}


Unterklasse erbt (die Attribute und Methoden) von Superklasse. 
Dies stellt eine \say{ist ein beziehung} dar. 
Es ist sehr wichtig, dass die Pfeilspitze \textbf{genau so} aussieht wie im in der Darstellung da ansonsten Verwechslungsgefahr mit anderen Mechanismen entstehen könnte.

\subsubsection{UML++}

Vererbung ist auch über mehrere Stufen Möglich:

\begin{center}
    \begin{tikzpicture}

        \umlemptyclass[x=2, y=4]{C1}

        \umlemptyclass[x=1, y=2]{C2}
        \umlemptyclass[x=3, y=2]{C3}

        \umlemptyclass{C4}
        \umlemptyclass[x=2]{C5}
        \umlemptyclass[x=4]{C6}

        
        \umlinherit{C2}{C1}
        \umlinherit{C3}{C1}

        \umlinherit{C4}{C2}
        \umlinherit{C5}{C2}
        \umlinherit{C6}{C3}

        \end{tikzpicture}   
\end{center}

C4 Erbt alles von C2 und C1, .....

\subsubsection{Syntax}

\lstinputlisting[language = c++]{code/vererbung_syntax.cpp}

Unterklasse erbt Superklasse.\\

Die Sichtbarkeit ist durch das Public definiert. 
Es ist möglich die Sichtbarkeit aller Attributen und Methoden einzuschränken. 
Mit \textbf{Public} wird alles mit der originalen Sichtbarkeit übernommen. 
Mit \textbf{protected} wird alles was public ist protected. 
Mit \textbf{private} wird alles private (nicht sehr nützlich).

Wird eine Vererbung private durchgeführt, sind keine Attribute oder Methoden mehr sichtbar.

\subsubsection{C/D tor chaining}

Grundsätzlich initialisieren ctors nur die eigene Klasse. 
Dh Superklassen initialisieren sich selbst. 
Eine Subklasse initialisiert sich, indem sie zunächst einen ctor der Superklasse aufruft und dann sich selbst \textbf{IMPLIZIT}. 
Man das auch explizit machen:

\lstinputlisting[language = c++]{code/ctor_unterklasse.cpp}

Note: Da der Konstruktor aufgerufen wird kann auch ein evtl Private Attribut der Oberklasse initialisiert werden.
Gleiches gilt mit dem Dtor, nur umgekehrte Reihenfolge (erst wird der Dtor von der subklasse aufgerufen, dann.....).

\subsection{Überschreiben von Methoden}

Geerbte Funktionen können \say{überschrieben} werden. 
Die Unterklasse definiert eine neue Methode mit demselben Namen.
Allerdings kann es dann zu Mehrdeutigkeit kommen:\\
Im folgenden Beispiel haben eine Subklasse und eine Oberklasse eine Print Funktion welche \textbf{Nicht} virtual gekennzeichnet ist:


\lstinputlisting[language = c++]{code/methodenueberschreiben.cpp}

Dieses Beispiel soll zeigen, dass Pointer, welche von auf einer Oberklasse auf eine Unterklasse zeigen auf die \say{Eigenen} Funktionen zeigt, solange diese nicht überschrieben worden sind.
Dies kann als Verhalten gewünscht sein. 


\subsection{Virtual, scopeoperator, override und final}

\subsubsection{virtual}

Mit virtual kann eine Methode kennzeichnen, dass diese Methode von einer Unterklasse überschrieben wird.
Somit würde das obige Beispiel nicht mehr funktionieren und es wird immer die Printfunktion der Unterklasse aufgerufen. 
In einer Unterklasse ist virtual nicht mehr zwingend zu schreiben.
Eine Klasse mit einer virtuellen Funktion wird als Polymorph bezeichnet.

\subsubsection{Virtual beim Dtor}

Ist eine Methode als virtual deklariert, so muss der Dtor \textbf{ZWINGEND} auch als virtual deklariert werden.

\subsubsection{Override}

Soll eine Methode eine geerbte Methode ersetzen so muss diese mit \say{Override} gekennzeichnet werden. 
Solch eine Methode ist automatisch auch virtual.
Der Compiler kann so überprüfen, ob eine virtual Methode vorhanden ist.

\subsubsection{Final}

Final kann zum einen verbieten, dass eine Methode einer Klasse überschrieben wird
(Logischerweise geht das nur bei virtuellen Methoden). 
Zum anderen kann sie auch das weitere Erben einer Klasse verbieten. 

\subsubsection{Scopeoperator}

Per Scopeoperator kann (::) eine Methode aus einer Oberklasse gezielt aufgerufen werden.
\todo[Scope Operator und Virtual]

\lstinputlisting[language = c++]{code/virtual.cpp}

\subsubsection{RTTI / Typing / Binding}

Wird kein Virtual verwendet, nennt man das static binding. 
Mit virtual wird es Dynamic binding genannt, da erst bei Laufzeit bekannt ist um welchen Pointer es sich handelt. 
Um bei Laufzeit herauszufinden um welchen Typ es sich handelt kann die Run-time Type Information verwendet werden. 
Mit dem \say{typeid} operator kann zur Laufzeit überprüft werden um welchen Typ es sich handelt. 
typeid gibt ein std::type\_info zurück. 

\lstinputlisting[language = c++]{code/RTTI.cpp}

\subsection{Abstrakte Klassen}

Wenn Klassen zwar festlegt, dass eine Methode da ist, diese aber noch nicht implementieren, nennt man das eine abstrakte Methode. 
Man spricht dann von einer abstrakten Klasse.
Eine abstrakte Methode wird in UML \textit{\textbf{kursiv}} dargestellt.
Es ist egal, ob die abstrakten Methoden selbst definiert sind oder geerbt. 
Abstrakte Klassen kann man nicht instanziieren.
Es gibt kein spezielles Schlüsselwort dafür, man weist der Methode bei Definition 0 zu: 

\lstinputlisting[language = c++]{code/abstraktemethode.cpp}

\subsection{Organisation der H files}

Generell gilt immer noch: Jedes H File hat ein Cpp File. 
Allerdings können Unterklassen in ein H File zusammengefasst werden, falls diese nicht allzu Umfänglich sind. 
Ansonsten sollt ein neues H File erstellt werden. 
Für abstrakte Klassen fällt die Implementierung in einem Cpp file weg.

\subsection{Mehrfachvererbung}

Folgender Vererbungszweig ist möglich:\\
\noindent
\begin{minipage}{0.5\columnwidth}
    \begin{center}
        \begin{tikzpicture}
    
            \umlemptyclass[x=1, y=4]{C1}
    
            \umlemptyclass[x=0, y=2]{C2}
            \umlemptyclass[x=2, y=2]{C3}
    
            \umlemptyclass[x=1]{C4}
            
            \umlinherit{C2}{C1}
            \umlinherit{C3}{C1}
    
            \umlinherit{C4}{C2}
            \umlinherit{C4}{C3}
    
            \end{tikzpicture}   
    \end{center}  
\end{minipage}
\begin{minipage}{0.5\columnwidth}
Solche Gebilde sind zwar möglich, aber zu verhindern da schnell sehr kompliziert und kaum lesbar. 
Es entsteht schnell Mehrdeutigkeit, durch die verschiedenen Erbzweige. 
Bei der Definition einer Klasse kann eine zweite Oberklasse diese mit einem Komma getrennt angegeben werden.

\end{minipage}

\lstinputlisting[language = c++]{code/Mehrfachvererbung.cpp}
