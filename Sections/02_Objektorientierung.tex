\section{Objektorientierung}

Objektorientierung soll es erleichtern eine Abbildung der Realität zu erstellen. 
Viele Dinge aus der Wirklichkeit können als Modell dargestellt / simplifiziert werden.\\
Diese Modelle können in Software in sogenannte Objekte \say{umgewandelt} werden.

\subsection{Objekte}

Objekte stellen Dinge, Sachverhalte oder Prozesse dar. Sie sind ein rein gedankliches Konzept.\\
Sie kennzeichnen sich durch:

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item eine Identität, welche es erlaubt Objekte voneinander zu unterscheiden
    \item statische Eigenschaften zur Darstellung des Zustandes des Objekts in Form von Attributen
    \item dynamische Eigenschaften zur Darstellung des Verhaltens des Objekts in Form von Methoden
\end{itemize}

\nextcol

\subsection{Klassen \& Instanzen}

Ähnliche Objekte können in \textbf{Klassen} zusammengefasst werden, um Programmieraufwand tiefer zu halten. 
Verwendete Objekte werden als \textbf{Instanz} eingesetzt. Diese Objekte haben dieselben Attribute, allerdings andere Werte.\\
Eine Beispielklasse:\\

\lstinputlisting[language = c++]{code/class_example.cpp}

\subsubsection{Header Datei}

Reihenfolge in der Header Datei

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Dateikommentar mit Lizenzvereinbarung.
    \item \say{Includes} des verwendete System Header
    \item \say{Includes} der Projektbezogenen Header
    \item Konstanten
    \item typdefs und definition von Strukturen
    \item Allenfalls extern-Deklraration von Global Variablen
    \item Funktionsprototypen, ink, Kommentar der Schnittstelle, bzw. Klassendeklarationen
\end{itemize}

Pro header Datei sollte nur eine Klasse deklariert sein.

\subsubsection{Reihenfolger der Implementation}

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Dateikommentar mit Lizenzvereinbarung
    \item \say{includes} der eigenen Header
    \item \say{includes} der Projektbezogenen Header
    \item \say{includes} der verwendeten System Header
    \item allenfalls globale und statischen Variablen
    \item Präprozessor-Direktiven
    \item Funktionsprototypen von lokalen, internen Funktionen (in nameless Namespace)
    \item Definition von Funktionen und Klassen
\end{itemize}

\subsection{UML}

Die \say{Unified Modeling Language} ist eine normierte Sprache um Objekte Grafisch darzustellen. 
Sie geht extrem ins Detail, allerdings 

\subsubsection{UML-Klassendiagramm Notation}

Besteht immer aus 3 Boxen:

\begin{center}
    \begin{tikzpicture} 
        \umlclass{Student}{ 
          + IDNumber : int \\ \#{} name : std::string \\ + bierkonsum : float \\ + investedTimeInET : long int 
          }{ 
          + doStuff(int time = 0) : void 
        } 
    \end{tikzpicture}   
\end{center}

Zu oberst der Name, in der Mitte Attribute(Variablen) und unten Methoden.\\
Die Methoden fangen mit einem Symbol an welches die Sichtbarkeit definiert:
\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item + public (überall sichtbar)
    \item - private (nur in  aktueller klasse sichtbar)
    \item \# protected (in aktueller und Unterklassen sichtbar)
\end{itemize}


\subsubsection{class \& struct}

Eine class und struct können fast identisch verwendet werden. 
Eine class hat standartmässig sichtbarkeit private, struct public(wenn nichts definiert wird).


\subsection{Inkludierte Dokumentation}

Mann im H-File direkt die Dokumentation zu der Schnittstelle schreiben. 
Das ermöglicht das einfachere Verwenden der Schnittstelle.
Dies wird in einem Blockkommentar, nach folgendem Muster realisiert:

\lstinputlisting[language = c++]{code/codedocumentation.cpp}

Es kann immer mehr geschrieben werden, es sollte sich aber auf das nötige beschränkt werden.

\section{Konstruktoren und Destruktoren}

Konstruktoren und Destruktoren sind spezielle Methoden von Klassen. 
Diese haben immer denselben Namen wie die Klasse und auch \textbf{kein} Rückgabetyp(auch nicht void).\\
Aufrufparameter haben folgende Bedeutung:

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item \textbf{\say{Keine}} : Default Konstruktor
    \item \textbf{\say{const-Referenz auf eigene Klasse}} : copy Konstruktor
    \item .....
\end{itemize}

\subsection{Konstruktoren}

Konstruktoren bereiten die Instanz auf ihre Funktion vor. \\

Wichtig ist das ein Konstruktor immer \textbf{alle} Attribute der Klasse initialisiert.
Konstruktoren werden wie folgt aufgerufen:\\

\subsubsection{User-Defined}

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Default $\rightarrow$ ohne Aufrufparameter
    \item Copy $\rightarrow$ mit einer const Referenz auf eine andere Instanz
    \item sonstige $\rightarrow$ werden anhand ihrer Aufrufparameter unterschieden, Sprechweise:\say{überladen}
\end{itemize}

Werden verschiedene Konstruktoren definiert, der Default aber soll erhalten bleiben, muss dieser in der Klassendefinition zuerst stehen.\\


\subsubsection{Implizit}

Falls ein expliziter nicht angegeben wurde, dieser jedoch aus technischen Gründen benötigt wird:

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Default $\rightarrow$ macht nichts, alle Parameter bleibe uninitialisiert
    \item Copy $\rightarrow$ dieser kopiert alle Attribute der anderen Instanz eins-zu-eins(bytewise). Problematisch, wenn die Instanz Pointer auf etwas hat.
    \item ...
\end{itemize}

Wenn ein Objekt ein Pointer auf einen Wert oder allokierten Speicher hat, muss eine spezielle Copy Methode verwendet werden, da der Pointerwert einfach kopiert wird.
Falls dann das erste Objekt den Speicher frei gibt, dann entsteht ein falscher Speicherzugriff.
DH mus dem Objekt ein separater Speicherbereich gegeben werden. 

Konstruktoren werden immer dann gerufen (evtl. auch \textbf{implizit}) wenn ein neues Objekt in den Speicher gelegt wird.\\

\subsection{Destruktor}

Destruktoren entfernen das Objekt aus dem Speicher. 
Hat keine Aufrufparameter und auch kein Rückgabewert.
Wenn der Destruktor fertig ist, sollte kein Speicher mehr vom Objekt belegt sein.\\
Destruktoren sollten immer \textbf{Virtuell definiert werden} und der Funktionsname beginnt mit einer Tilde. 
Der Destruktor wird evtl. auch Implizit aufgerufen z.b., wenn aus einer Funktion wieder herausgesprungen wird. 
\nextcol

\subsection{Beispiel}

\lstinputlisting[language = c++]{code/constructor.cpp}

\section{Initialisierungslisten und direkte Initialisierung}

Die Initialisierung von Datentypen kann auf verschiedene Arten erreicht werden. 
Es wird zwischen Zuweisung und Initialisierung unterschieden.

\subsection{POD's}

\say{plain old datastructure} / built in 

\lstinputlisting[language = c++]{code/pod_init.cpp}

\subsection{Non PODs}

\lstinputlisting[language = c++]{code/non_pod_init.cpp}

\subsection{User defined Ctor}

Um eine Klasse richtig initialisieren zu können muss der Ctor korrekt definiert werden. 
Eine sogenannte Initialisierungsliste:

\lstinputlisting[language = c++]{code/userdefined_ctro.cpp}

\section{Assertions}

Assertions sollten Annahmen über korrekte Wertebelegung darstellen. 
Sie sind kein C spezifisches Konzept und sollten nur zu Testzwecken eingesetzt werden. 
Im Releasebuild sollten sie deaktiviert werden. 
Dafür gibt es spezifische Präprozessorflags.
Der Header assert.h bzw. cassert stellt hierfür ein Präprozessor-Makro \say{assert(Bedingung)} zur Verfügung, um solche Zusicherungen auszudrücken.\\
Beispiel:\\

\lstinputlisting[language = c++]{code/assertions.cpp}

Das obige Beispiel hat eine Assertion. 
Diese würde im Test, falls ein Nullpointer übergeben wird ein Fehler ausgegeben. 

\section{Referenzen}

Referenzen sind die modernere / eingeschränkte Version von Pointer. 
Wenn möglich sollte immer mit Referenzen gearbeitet werden, dies ist aber nicht immer möglich.\\

Referenzen...
\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item wirken wie ein Alias-Name einer Variablen
    \item werden wie normale Variablen verwendet
    \item sind niemals uninitialisiert
    \item haben niemals den Wert nullptr
    \item brauchen nicht immer speicher(Implementation abhängig)
\end{itemize}

Generell helfen Referenzen weniger Fehler in der Programmierung zu machen und weniger Risiken zu haben. 
Pointer werden allerdings weiter für sehr hardwarenahe Programmierung gebraucht. 
Sizeof() liefert die Grösse des Typs, auf der die Referenz zeigt.\\
Beispiel:

\lstinputlisting[language = c++]{code/referenz.cpp}