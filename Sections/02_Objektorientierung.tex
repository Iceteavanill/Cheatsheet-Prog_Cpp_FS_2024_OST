\section{Objektorientierung}

Objektorientierung soll es erleichtern eine Abbildung der Realität zu erstellen. 
Viele Dinge aus der Wirklichkeit können als Modell dargestellt / simplifiziert werden.\\
Diese Modelle können in Software in sogenannte Objekte \say{umgewandelt} werden.

\subsection{Objekte}

Objekte stellen Dinge, Sachverhalte oder Prozesse dar. Sie sind ein rein gedankliches Konzept.\\
Sie kennzeichnen sich durch:

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item eine Identität, welche es erlaubt Objekte voneinander zu unterscheiden
    \item statische Eigenschaften zur Darstellung des Zustandes des Objekts in Form von Attributen
    \item dynamische Eigenschaften zur Darstellung des Verhaltens des Objekts in Form von Methoden
\end{itemize}

\nextcol

\subsection{Klassen \& Instanzen}

Ähnliche Objekte können in \textbf{Klassen} zusammengefasst werden, um Programmieraufwand tiefer zu halten. 
Verwendete Objekte werden als \textbf{Instanz} eingesetzt. Diese Objekte haben dieselben Attribute, allerdings andere Werte.\\
Eine Beispielklasse:\\

\lstinputlisting[language = c++]{code/class_example.cpp}

\subsubsection{Header Datei}

Reihenfolge in der Header Datei

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Dateikommentar mit Lizenzvereinbarung.
    \item \say{Includes} des verwendete System Header
    \item \say{Includes} der Projektbezogenen Header
    \item Konstanten
    \item typdefs und definition von Strukturen
    \item Allenfalls extern-Deklraration von Global Variablen
    \item Funktionsprototypen, ink, Kommentar der Schnittstelle, bzw. Klassendeklarationen
\end{itemize}

Pro header Datei sollte nur eine Klasse deklariert sein.

\subsubsection{Reihenfolger der Implementation}

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Dateikommentar mit Lizenzvereinbarung
    \item \say{includes} der eigenen Header
    \item \say{includes} der Projektbezogenen Header
    \item \say{includes} der verwendeten System Header
    \item allenfalls globale und statischen Variablen
    \item Präprozessor-Direktiven
    \item Funktionsprototypen von lokalen, internen Funktionen (in nameless Namespace)
    \item Definition von Funktionen und Klassen
\end{itemize}

\subsection{UML}

Die \say{Unified Modeling Language} ist eine normierte Sprache um Objekte Grafisch darzustellen. 
Sie geht extrem ins Detail, allerdings 

\subsubsection{UML-Klassendiagramm Notation}

Besteht immer aus 3 Boxen:

\begin{center}
    \begin{tikzpicture} 
        \umlclass{Student}{ 
          + IDNumber : int \\ \#{} name : std::string \\ + bierkonsum : float \\ + investedTimeInET : long int 
          }{ 
          + doStuff(int time = 0) : void 
        } 
    \end{tikzpicture}   
\end{center}

Zu oberst der Name, in der Mitte Attribute(Variablen) und unten Methoden.\\
Die Methoden fangen mit einem Symbol an welches die Sichtbarkeit definiert:
\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item + public (überall sichtbar)
    \item - private (nur in  aktueller klasse sichtbar)
    \item \# protected (in aktueller und Unterklassen sichtbar)
\end{itemize}


\subsubsection{class \& struct}

Eine class und struct können fast identisch verwendet werden. 
Eine class hat standartmässig sichtbarkeit private, struct public(wenn nichts definiert wird).


\subsection{Inkludierte Dokumentation}

Mann im H-File direkt die Dokumentation zu der Schnittstelle schreiben. 
Das ermöglicht das einfachere Verwenden der Schnittstelle.
Dies wird in einem Blockkommentar, nach folgendem Muster realisiert:

\lstinputlisting[language = c++]{code/codedocumentation.cpp}

Es kann immer mehr geschrieben werden, es sollte sich aber auf das nötige beschränkt werden.

\section{Konstruktoren und Destruktoren}

Konstruktoren und Destruktoren sind spezielle Methoden von Klassen. 
Diese haben immer denselben Namen wie die Klasse und auch \textbf{kein} Rückgabetyp(auch nicht void).\\
Aufrufparameter haben folgende Bedeutung:

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item \textbf{\say{Keine}} : Default Konstruktor
    \item \textbf{\say{const-Referenz auf eigene Klasse}} : copy Konstruktor
    \item .....
\end{itemize}

\subsection{Konstruktoren}

Konstruktoren bereiten die Instanz auf ihre Funktion vor. \\

Wichtig ist das ein Konstruktor immer \textbf{alle} Attribute der Klasse initialisiert.
Konstruktoren werden wie folgt aufgerufen:\\

\subsubsection{User-Defined}

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Default $\rightarrow$ ohne Aufrufparameter
    \item Copy $\rightarrow$ mit einer const Referenz auf eine andere Instanz
    \item sonstige $\rightarrow$ werden anhand ihrer Aufrufparameter unterschieden, Sprechweise:\say{überladen}
\end{itemize}

Werden verschiedene Konstruktoren definiert, der Default aber soll erhalten bleiben, muss dieser in der Klassendefinition zuerst stehen.\\


\subsubsection{Implizit}

Falls ein expliziter nicht angegeben wurde, dieser jedoch aus technischen Gründen benötigt wird:

\begin{itemize}[itemsep=1pt, parsep=0pt]
    \item Default $\rightarrow$ macht nichts, alle Parameter bleibe uninitialisiert
    \item Copy $\rightarrow$ dieser kopiert alle Attribute der anderen Instanz eins-zu-eins(bytewise). Problematisch, wenn die Instanz Pointer auf etwas hat.
    \item ...
\end{itemize}

Wenn ein Objekt ein Pointer auf einen Wert oder allokierten Speicher hat, muss eine spezielle Copy Methode verwendet werden, da der Pointerwert einfach kopiert wird.
Falls dann das erste Objekt den Speicher frei gibt, dann entsteht ein falscher Speicherzugriff.
DH mus dem Objekt ein separater Speicherbereich gegeben werden. 

Konstruktoren werden immer dann gerufen (evtl. auch \textbf{implizit}) wenn ein neues Objekt in den Speicher gelegt wird.\\

\subsection{Destruktor}

Destruktoren entfernen das Objekt aus dem Speicher. 
Hat keine Aufrufparameter und auch kein Rückgabewert.
Wenn der Destruktor fertig ist, sollte kein Speicher mehr vom Objekt belegt sein.\\
Destruktoren sollten immer \textbf{Virtuell definiert werden} und der Funktionsname beginnt mit einer Tilde. 
Der Destruktor wird evtl. auch Implizit aufgerufen z.b., wenn aus einer Funktion wieder herausgesprungen wird. 
\nextcol

\subsection{Beispiel}

\lstinputlisting[language = c++]{code/constructor.cpp}

\section{Initialisierungslisten und direkte Initialisierung}

Die Initialisierung von Datentypen kann auf verschiedene Arten erreicht werden. 
Es wird zwischen Zuweisung und Initialisierung unterschieden.

\subsection{POD's}

\say{plain old datastructure} / built in 

\lstinputlisting[language = c++]{code/pod_init.cpp}

\subsection{Non PODs}

\lstinputlisting[language = c++]{code/non_pod_init.cpp}

\subsection{User defined Ctor}

Um eine Klasse richtig initialisieren zu können muss der Ctor korrekt definiert werden. 
Eine sogenannte Initialisierungsliste:

\lstinputlisting[language = c++]{code/userdefined_ctro.cpp}

\section{Assertions}

Assertions sollten Annahmen über korrekte Wertebelegung darstellen. 
Sie sind kein C spezifisches Konzept und sollten nur zu Testzwecken eingesetzt werden. 
Im Releasebuild sollten sie deaktiviert werden. 
Dafür gibt es spezifische Präprozessorflags.
Der Header assert.h bzw. cassert stellt hierfür ein Präprozessor-Makro \say{assert(Bedingung)} zur Verfügung, um solche Zusicherungen auszudrücken.\\
Beispiel:\\

\lstinputlisting[language = c++]{code/assertions.cpp}

Das obige Beispiel hat eine Assertion. 
Diese würde im Test, falls ein Nullpointer übergeben wird ein Fehler ausgegeben. 

\subsection{This-Pointer}

Mit dem \say{this Pointer} kann ein Pointer des aufrufenden Objekt zurückgegeben werden. Bsp:

\lstinputlisting[language = c++]{code/this_pointer.cpp}

Nacheinander werden diese Funktionen durchlaufen da Funktion(2) vom zurückgegebenen Pointer aus Funktionsaufruf 1 aus gerufen wird.
Die funktion wird \say{Kaskadiert}


\section{Overloading}

Operator Overloading bedeutet das bestehende Operatoren \say{überladen} werden im Sinne neu definiert / drüber laden und erhalten neue bedeutung für eine Klasse. 


\subsubsection{Methodenoverloading}

Methoden dürfen in Cpp gleich heissen, sie müssen aber unterschiedliche Aufrufparameter haben.
\lstinputlisting[language = c++]{code/method_overloading.cpp}


\subsection{Operator overloading}

Es können die inkludierten Operatoren von Cpp überladen werden. 
Erlaubte Operatoren sind:\\
\begin{tabular}{lllllllll}
    +            & -               & *           & ⁄                      & \%                           & $\wedge$                & \&                            & |                & $\sim$          \\
    !            & =               & \textless{} & \textgreater{}         & +=                           & -=                      & *=                            & ⁄=               & \%=             \\
    $\wedge$=    & \&=             & |=          & \textless{}\textless{} & \textgreater{}\textgreater{} & \textless{}\textless{}= & \textgreater{}\textgreater{}= & ==               & !=              \\
    \textless{}= & \textgreater{}= & \&\&        & ||                     & ++                           & --                      & ,                             & -\textgreater{}* & -\textgreater{} \\
    ( )          & {[} {]}         & new         & delete                 & new{[}{]}                    & delete{[}{]}            &                               &                  &                
\end{tabular}

Nicht erlaubte Operatoren sind: \say{.}, \say{.*}, \say{::} und \say{?:}.

Es wird zwischen overloading global und in Methode unterschieden.

\subsubsection{Global}

Globales overloading funktioniert mit einer als \say{friend} deklarierten Funktion. 
Als friend deklarierte Funktionen agieren als globale Funktion und haben vollen zugriff auf alle Parameter einer Klasse. 
Sie sind daher zu vermeiden da sie eher ein Workaround sind und zu Problemen führen können.\\ 

Syntax : \say{return-type} operator\say{typ}(type val1, type val2);\\
BSP:\\

\lstinputlisting[language = c++]{code/operator_overloading_global.cpp}

Die Funktion kann von überall aus dem Programm ausgeführt werden. 
Es sollte nur dann verwendet werden wenn der erste Parameter (links) nicht eine Instanz der Klasse ist da der Erste Aufrufparameter immer die Instanz sein muss.  

\subsubsection{Methoden}

Ein Operator kann auch als Methode einer Klasse definiert werden. 
Sie haben nur noch ein Aufrufparameter.\\
Syntax : \say{return-type} operator\say{typ}(type in);\\
Der 2. Parameter ist das Objekt selbst, welche die Methode aufruft.

\lstinputlisting[language = c++]{code/operator_overloading_method.cpp}

Die obigen Funktionen machen alle dasselbe. 
Sie unterscheiden sich durch die unterschiedlichen Argumente. 
Diese decken verschiedene Eingabetypen ab. 
Es wäre schlechter Stil, die Typkonvertierung dem Compiler implizit zu überlassen! 
Ein Fall, der bei dem das anderstypige Argument zuerst kommt, muss noch per Globalem Overloading gelöst werden, da der Erste Aufrufparameter, beim overloading mit Methoden, immer zuerst kommt. 
 
\subsection{Default Argumente}

Default Argumente werden, als Parameterwert verwendet, wenn keiner mitgegeben wird.
Parameter werden von links nach rechts werten belegt. 
Daher, wenn manche Aufrufparameter keinen Default wert erhalten, müssen diese weiter links, als welche mit Default wert stehen.  

\lstinputlisting[language = c++]{code/default_argumente.cpp}

Default Argumente können überall verwendet werden, bei Aufrufparameter von Operatoroverloading macht es lediglich keinen Sinn.

\subsection{Getter \& Settermethoden}

Getter und Settermethoden werden Typischerweise verwendet um lese und Schreibzugriffe auf eine Klasse zu regeln. 
Attribute sind typischerweise privat. 
Mit einer Get oder Set methode kann dieser kontrollierter angepasst  werden.\\

\lstinputlisting[language = c++]{code/getter_settermethoden.cpp}

\subsection{Vererbung}

Vererbung erlaubt es Attribute und Methoden von anderen Klassen zu übernehmen. 
Die Oberklasse, Baisklasse oder superklasse \say{vererbt} an eine Unterklasse, derived class oder eine Spezialisierung. 
Bei der Vererbung werden immer \textbf{Alle} Attribute oder Methoden weitergegeben.  


\subsubsection{UML}

In einem UML Diagramm wird vererbung wie folgt dargestellt:\\

\begin{center}
    \begin{tikzpicture} 
        \umlclass{Superklasse}{....}{...}
        \umlclass[x=5]{Unterklasse}{...}{...}
        \umlinherit{Unterklasse}{Superklasse}
    \end{tikzpicture}   
\end{center}


Unterklasse erbt die Attribute und Methoden von Superklasse.
Es ist sehr wichtig, dass die Pfeilspitze \textbf{genau so} aussieht wie im in der Darstellung da ansonsten Verwechslungsgefahr mit anderen Mechanismen entstehen könnte.

\subsubsection{UML++}

Vererbung ist auch über mehrere Stufen Möglich:

\begin{center}
    \begin{tikzpicture}

        \umlemptyclass[x=2, y=4]{C1}

        \umlemptyclass[x=1, y=2]{C2}
        \umlemptyclass[x=3, y=2]{C3}

        \umlemptyclass{C4}
        \umlemptyclass[x=2]{C5}
        \umlemptyclass[x=4]{C6}

        
        \umlinherit{C2}{C1}
        \umlinherit{C3}{C1}

        \umlinherit{C4}{C2}
        \umlinherit{C5}{C2}
        \umlinherit{C6}{C3}

        \end{tikzpicture}   
\end{center}

C4 Erbt alles von C2 und C1, .....

\subsubsection{Syntax}

\lstinputlisting[language = c++]{code/vererbung_syntax.cpp}

Unterklasse erbt Superklasse.\\

Die Sichtbarkeit ist durch das Public definiert. 
Es ist möglich die Sichtbarkeit aller Attributen und Methoden einzuschränken. 
Mit \textbf{Public} wird alles mit der originalen Sichtbarkeit übernommen. 
Mit \textbf{protected} wird alles was public ist protected. 
Mit \textbf{private} wird alles private (nicht sehr nützlich).

\subsubsection{C/D tor chaining}

Grundsätzlich initialisieren ctors nur die eigene Klasse. 
Dh Superklassen initialisieren sich selbst. 
Eine Subklasse initialisiert sich indem sie zunächst einen ctor der Superklasse aufruft und dann sich selbst:

\lstinputlisting[language = c++]{code/ctor_unterklasse.cpp}

Gleiches gilt mit dem Dtor, nur umgekehrt.



